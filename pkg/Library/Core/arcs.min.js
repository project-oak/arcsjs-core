var J=Object.defineProperty;var xt=(r,t,e)=>t in r?J(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var G=(r,t)=>{for(var e in t)J(r,e,{get:t[e],enumerable:!0})};var b=(r,t,e)=>(xt(r,typeof t!="symbol"?t+"":t,e),e);var h=class{listeners={};getEventListeners(t){return this.listeners[t]||(this.listeners[t]=[])}fire(t,...e){let s=this.getEventListeners(t);s?.forEach&&s.forEach(o=>o(...e))}listen(t,e,s){return this.getEventListeners(t).push(e),e._name=s||"(unnamed listener)",e}unlisten(t,e){let s=this.getEventListeners(t),o=typeof e=="string"?s.findIndex(i=>i._name===e):s.indexOf(e);o>=0?s.splice(o,1):console.warn("failed to unlisten from",t)}};var V=["log","group","groupCollapsed","groupEnd","dir"],Q=["warn","error"];var{fromEntries:X}=Object,Y=(r,t,e,s,o="log")=>{if(typeof r=="string"&&(r=n.flags[r]),!r)return()=>{};if(o==="dir")return console.dir.bind(console);let i=`background: ${e||"gray"}; color: ${s||"white"}; padding: 1px 6px 2px 7px; border-radius: 6px 0 0 6px;`;return console[o].bind(console,`%c${t}`,i)},n=(r,t,e="",s="")=>{let o=X(V.map(l=>[l,Y(r,t,e,s,l)])),i=X(Q.map(l=>[l,Y(!0,t,e,s,l)])),a={...o,...i},c=a.log;return Object.assign(c,a),c};n.flags=globalThis.config?.logFlags||{};var Pt=r=>n(n.flags.arc,`Arc (${r})`,"slateblue"),{assign:vt,create:bt}=Object,Z=r=>Object.entries(r??Object),F=r=>Object.keys(r??Object),w=r=>Object.values(r??Object),D=()=>bt(null),O=class extends h{log;id;meta;stores;hosts;surface;composer;hostService;constructor(t,e,s){super(),this.id=t,this.meta=e,this.surface=s,this.hosts=D(),this.stores=D(),this.log=Pt(t)}async addHost(t,e){return await this.ensureComposer(),this.hosts[t.id]=t,t.arc=this,this.updateHost(t),t}async ensureComposer(){!this.composer&&this.surface&&(this.composer=await this.surface.createComposer("root"),this.composer.onevent=this.onevent.bind(this))}rerender(){w(this.hosts).forEach(t=>t.rerender())}removeHost(t){this.hosts[t]?.detach(),delete this.hosts[t]}addStore(t,e){e&&!this.stores[t]&&(this.stores[t]=e,e.listen("change",()=>this.storeChanged(t,e),this.id))}removeStore(t){let e=this.stores[t];e&&e.unlisten("change",this.id),delete this.stores[t]}storeChanged(t,e){this.log(`storeChanged: "${t}"`);let s=o=>o&&o.some(i=>i&&(w(i)[0]==t||F(i)[0]==t));w(this.hosts).forEach(o=>{let i=o.meta?.inputs;(i==="*"||s(i))&&(this.log(`host "${o.id}" has interest in "${t}"`),this.updateHost(o))}),this.fire("store-changed",t)}updateParticleMeta(t,e){let s=this.hosts[t];s.meta=e,this.updateHost(s)}updateHost(t){t.inputs=this.computeInputs(t)}computeInputs(t){let e=D(),s=t.meta?.inputs;if(s==="*")Z(this.stores).forEach(([o,i])=>e[o]=i.pojo);else{let o=t.meta?.staticInputs;vt(e,o),s&&(s.forEach(i=>i&&this.computeInput(Z(i)[0],e)),this.log(`computeInputs(${t.id}) =`,e))}return e}computeInput([t,e],s){let o=e||t,i=this.stores[o];i&&(s[t]=i.pojo)}assignOutputs({id:t,meta:e},s){let o=F(s);e?.outputs&&o.length&&(o.forEach(i=>this.assignOutput(i,s[i],e.outputs)),this.log(`[end][${t}] assignOutputs:`,s))}assignOutput(t,e,s){if(e!==void 0){let o=this.findOutputByName(s,t)||t,i=this.stores[o];i?(this.log(`assignOutputs: "${t}" is dirty, updating Store "${o}"`,e),i.data=e):s?.[t]&&this.log.warn(`assignOutputs: no "${o}" store for output "${t}"`)}}findOutputByName(t,e){let s=t?.find(o=>F(o||0)[0]===e);if(s)return w(s)[0]}async render(t){this.composer&&this.composer.render({...t,arcid:this.id})}onevent(t,e){let s=this.hosts[t];s&&s.handleEvent(e)}async service(t,e){let s=await this.surface?.service(e);return s===void 0&&(s=this.hostService?.(t,e)),s}};var wt=(r,t)=>{let e=t;if(t){if(Array.isArray(t)){Array.isArray(r)||(r=[]);for(let o=0;o<t.length;o++){let i=t[o];r[o]!==i&&(r[o]=i)}let s=r.length-t.length;s>0&&r.splice(t.length,s)}else if(typeof t=="object"){e=r&&typeof r=="object"?r:Object.create(null);let s={};Object.keys(t).forEach(o=>{e[o]=t[o],s[o]=!0}),Object.keys(e).forEach(o=>{s[o]||delete e[o]})}}return e},Ot=(r,t)=>{if(t==null)return null;if(typeof t=="object"){let e=r&&typeof r=="object"?r:Object.create(null);return Object.keys(t).forEach(s=>e[s]=t[s]),e}return t};function u(r){if(r){if(Array.isArray(r))return r.map(t=>u(t));if(typeof r=="object"){let t=Object.create(null);return Object.entries(r).forEach(([e,s])=>{t[e]=u(s)}),t}else return r}else return r}var d=(r,t)=>{let e=typeof r;if(e!==typeof t)return!1;if(e==="object"&&r&&t){let s=Object.getOwnPropertyNames(r),o=Object.getOwnPropertyNames(t);return s.length==o.length&&!s.some(i=>!d(r[i],t[i]))}return r===t},tt=r=>r===void 0?null:(r&&typeof r=="object"&&Object.getOwnPropertyNames(r).forEach(e=>{let s=r[e];s===void 0?delete r[e]:tt(s)}),r);var{floor:et,pow:Et,random:N}=Math,jt=r=>et((1+N()*9)*Et(10,r-1)),E=r=>et(N()*r),k=r=>r[E(r.length)],Ct=r=>Boolean(N()<r);var z=n(n.flags.decorator,"Decorator","plum"),{values:Tt,entries:rt}=Object,st={},M={setOpaqueData(r,t){return st[r]=t,r},getOpaqueData(r){return st[r]},maybeDecorateModel(r,t){return r&&!Array.isArray(r)&&Tt(r).forEach(e=>{e&&typeof e=="object"&&(e.models?(z("applying decorator(s) to list:",e),this.maybeDecorateItem(e,t)):(r?.filter||r?.decorator||r?.collateBy)&&(z("scanning for lists in sub-model:",e),this.maybeDecorateModel(e,t)))}),r},maybeDecorateItem(r,t){let e=typeof r.models=="string"?this.getOpaqueData(r.models):r.models;e&&(e=Ft(e,r.decorator,t),e=Dt(e,r.filter,t.impl),e=Nt(e,r),r.models=e)}},Ft=(r,t,e)=>{t=e.impl[t]??t;let{inputs:s,state:o}=e.internal;if(t){let i=Object.freeze(u(s)),a=Object.freeze(u(o));r=r.map(c=>{c.privateData=c.privateData||{};let l=Object.freeze(u(c)),v=t(l,i,a);return c.privateData=v.privateData,{...v,...c}}),r.sort(kt("sortKey")),z("decoration was performed")}return r},Dt=(r,t,e)=>(t=e[t]??t,t&&r&&(r=r.filter(t)),r),Nt=(r,t)=>(rt(t).forEach(([e,s])=>{if(s?.collateBy){let o=Mt(r,s.collateBy);r=At(o,e,s.$template)}}),r),kt=r=>(t,e)=>zt(String(t[r]).toLowerCase(),String(e[r]).toLowerCase()),zt=(r,t)=>r<t?-1:r>t?1:0,Mt=(r,t)=>{let e={};return r.forEach(s=>{let o=s[t];o&&(e[o]||(e[o]=[])).push(s)}),e},At=(r,t,e)=>rt(r).map(([s,o])=>({key:s,[t]:{models:o,$template:e},single:o.length===1,...o?.[0]}));var{entries:ot,keys:Bt}=Object,Lt=r=>n(n.flags.host,`Host (${r})`,k(["#5a189a","#51168b","#48137b","#6b2fa4","#7b46ae","#3f116c"])),g=class extends h{arc;id;lastOutput;lastPacket;lastRenderModel;log;meta;particle;constructor(t){super(),this.log=Lt(t),this.id=t}onevent(t){this.arc?.onevent(t),this.fire("eventlet",t)}installParticle(t,e){this.particle&&this.detachParticle(),t&&(this.particle=t,this.meta=e||this.meta)}get container(){return this.meta?.container||"root"}detach(){this.detachParticle(),this.arc=null}detachParticle(){this.particle&&(this.render({$clear:!0}),this.particle=null,this.meta=null)}async service(t){return t?.decorate?M.maybeDecorateModel(t.model,this.particle):this.arc?.service(this,t)}output(t,e){t&&(this.lastOutput=t,this.arc?.assignOutputs(this,t),this.fire("output",t)),this.template&&(M.maybeDecorateModel(e,this.particle),this.lastRenderModel={...e},this.render(e))}rerender(){this.lastRenderModel&&this.render(this.lastRenderModel)}render(t){let{id:e,container:s,template:o}=this,a={id:e,container:s,content:{model:t,template:o}};this.fire("render",a),this.arc?.render(a),this.lastPacket=a}set inputs(t){if(this.particle&&t){let e=this.particle.internal.inputs;this.dirtyCheck(t,e,this.lastOutput)?(this.particle.inputs=u({...this.meta?.staticInputs,...t}),this.fire("inputs-changed")):this.log("inputs are uninteresting, skipping update")}}dirtyCheck(t,e,s){let o=([i,a])=>s?.[i]&&!d(s[i],a)||!d(e?.[i],a);return!e||ot(t).length!==this.lastInputsLength(e)||ot(t).some(o)}lastInputsLength(t){return Bt(t).filter(e=>!this.meta?.staticInputs?.[e]&&e!=="eventlet").length}get config(){return this.particle?.config}get template(){return this.config?.template}invalidate(){this.particle?.invalidate()}handleEvent(t){return this.particle?.handleEvent(t)}};var{create:Ht,keys:Ut}=Object,{stringify:it,parse:at}=JSON,A=class extends h{privateData;constructor(){super()}setPrivateData(t){this.privateData=t}set data(t){this.setPrivateData(t)}get data(){return this.privateData}toString(){return this.pretty}get isObject(){return this.data&&typeof this.data=="object"}get pojo(){return this.data}get json(){return it(this.data)}set json(t){let e=null;try{e=at(t)}catch{}this.data=e}get pretty(){let t={},e=this.pojo;return Ut(e).sort().forEach(s=>t[s]=e[s]),it(t,null,"  ")}},B=class extends A{change(t){t(this),this.doChange()}doChange(){this.fire("change",this),this.onChange(this)}onChange(t){}set data(t){this.change(e=>e.setPrivateData(t))}get data(){return this.privateData}set(t,e){this.data||this.setPrivateData(Ht(null)),e!==void 0?this.change(s=>s.data[t]=e):this.delete(t)}delete(t){this.change(e=>delete e.data[t])}},L=class extends B{meta;constructor(t){super(),this.meta={...t}}toString(){return`${JSON.stringify(this.meta,null,"  ")}, ${this.pretty}`}get tags(){return this.meta.tags??(this.meta.tags=[])}is(...t){return t.every(e=>this.tags.includes(e))}isCollection(){return this.meta.type?.[0]==="["}shouldPersist(){return this.is("persisted")&&!this.is("volatile")}async doChange(){return this.persist(),super.doChange()}async persist(){}async restore(){}save(){return this.json}load(t,e){let s=e;try{t&&(s=at(t))}catch{}s!==void 0&&(this.data=s)}},j=class extends L{};var m=(r,t,e)=>{r=r||2,t=t||2,e=e||"-";let s=Math.pow(10,t-1),o=Math.pow(10,t)-s,i=[];for(let a=0;a<r;a++)i.push(`${E(o-s)+s}`);return i.join(e)};var nt=n(n.flags.runtime,"runtime","#873600"),ct={},H={},{keys:Rt}=Object,U=class extends h{log;uid;nid;arcs;stores;peers;shares;endpoint;network;surfaces;persistor;prettyUid;constructor(t){t=t||"user",super(),this.arcs={},this.surfaces={},this.stores={},this.peers=new Set,this.shares=new Set,this.setUid(t),this.log=n(n.flags.runtime,`runtime:[${this.prettyUid}]`,"#873600")}setUid(t){this.uid=t,this.nid=`${t}:${m(1,2)}`,this.prettyUid=t.substring(0,t.indexOf("@")+1)||t}async bootstrapArc(t,e,s,o){let i=new O(t,e,s);return i.hostService=this.serviceFactory(o),await this.addArc(i),i}serviceFactory(t){return async(e,s)=>t.handle(this,e,s)}async bootstrapParticle(t,e,s){let o=new g(e);return await this.marshalParticle(o,s),await t.addHost(o),nt("bootstrapped particle",e),o}addSurface(t,e){this.surfaces[t]=e}getSurface(t){return this.surfaces[t]}addArc(t){let{id:e}=t;if(e&&!this.arcs[e])return this.arcs[e]=t;throw`arc has no id, or id "${e}" is already in use`}removeArc(t){let{id:e}=t;if(!e||!this.arcs[e])throw e?`id "${e}" is not in use`:"arc has no id";delete this.arcs[e]}async marshalParticle(t,e){let s=await this.createParticle(t,e.kind);return t.installParticle(s,e)}async installParticle(t,e,s){if(this.log("installParticle",s,e,t.id),s=s||m(),t.hosts[s]){let i=1;for(;t.hosts[`${s}-${i}`];i++);s=`${s}-${i}`}let o=new g(s);return await this.marshalParticle(o,e),await t.addHost(o),o}async addParticle(t,e,s,o){return this.log("addParticle",t.id,o,s,t.id),await this.marshalParticle(e,s),await t.addHost(e),e}idFromName(t,e){let s=t||m();if(e[s]){let o=1;for(;e[`${s}-${o}`];o++);s=`${s}-${o}`}return s}addStore(t,e){e.marshal&&e.marshal(this),e.persist=async()=>this.persistStore(t,e),e.restore=async()=>this.restoreStore(t,e);let s=`${this.nid}:${t}-changed`,o=this.storeChanged.bind(this,t);e.listen("change",o,s),this.stores[t]=e,this.maybeShareStore(t)}async persistStore(t,e){if(e.shouldPersist())return this.log(`persistStore "${t}"`),this.persistor?.persist?.(t,e.data)}async restoreStore(t,e){if(e.shouldPersist())return this.log(`restoreStore "${t}"`),this.persistor?.restore?.(t)}storeChanged(t,e){this.log("storeChanged",t),this.network?.invalidatePeers(t),this.onStoreChange(t,e),this.fire("store-changed",{storeId:t,store:e})}onStoreChange(t,e){}do(t,e){e(this.stores[t])}removeStore(t){this.do(t,e=>{e?.unlisten("change",`${this.nid}:${t}-changed`)}),delete this.stores[t]}maybeShareStore(t){this.do(t,e=>{e?.is("shared")&&this.shareStore(t)})}addPeer(t){this.peers.add(t),[...this.shares].forEach(e=>this.maybeShareStoreWithPeer(e,t))}shareStore(t){this.shares.add(t),[...this.peers].forEach(e=>this.maybeShareStoreWithPeer(t,e))}maybeShareStoreWithPeer(t,e){this.do(t,s=>{let o=this.uid.replace(/\./g,"_");(!s.is("private")||e.startsWith(o))&&this.shareStoreWithPeer(t,e)})}shareStoreWithPeer(t,e){this.network?.shareStore(t,e)}async createParticle(t,e){try{return(await this.marshalParticleFactory(e))?.(t)}catch(s){nt.error(`createParticle(${e}):`,s)}}async marshalParticleFactory(t){return ct[t]??this.lateBindParticle(t)}lateBindParticle(t,e){let{particleOptions:s,particleIndustry:o,registerFactoryPromise:i}=U;if(o){let a=o(t,{...s,code:e});return i(t,a),a}else throw`no ParticleIndustry to create '${t}'`}static registerFactoryPromise(t,e){return ct[t]=e}requireStore(t){let e=this.stores[t.name];return e||(e=this.createStore(t),this.addStore(t.name,e)),e}createStore(t){let e=Rt(H).find(o=>t.tags?.includes?.(o)),s=H[String(e)]||j;return new s(t)}static registerStoreClass(t,e){H[t]=e}},y=U;b(y,"securityLockdown"),b(y,"particleIndustry"),b(y,"particleOptions");var R=n(n.flags.recipe,"RecipeParser","violet"),{entries:Wt,create:qt}=Object,$=class{stores;particles;slots;meta;constructor(t){this.stores=[],this.particles=[],this.slots=[],this.meta=qt(null),t&&this.parse(t)}parse(t){let e=this.normalize(t);return this.parseSlotSpec(e,"root",""),this}normalize(t){if(typeof t!="object")throw Error("recipe must be an Object");return t}parseSlotSpec(t,e,s){for(let o in t)switch(o){case"$meta":this.meta={...this.meta,...t.$meta};break;case"$stores":this.parseStoresNode(t.$stores);break;default:{let i=s?`${s}#${e}`:e;this.parseParticleSpec(i,o,t[o]);break}}}parseStoresNode(t){for(let e in t)this.parseStoreSpec(e,t[e])}parseStoreSpec(t,e){if(this.stores.find(o=>o.name===t)){R("duplicate store name");return}let s={name:t,type:e.$type,tags:e.$tags,value:e.$value};this.stores.push(s)}parseParticleSpec(t,e,s){if(!s.$kind)throw R.warn('parseParticleSpec: malformed spec has no "kind":',s),Error();if(this.particles.find(o=>o.id===e)){R("duplicate particle name",e,s);return}this.particles.push({id:e,container:t,spec:s}),s.$slots&&this.parseSlotsNode(s.$slots,e)}parseSlotsNode(t,e){Wt(t).forEach(([s,o])=>this.parseSlotSpec(o,s,e))}};function W(r,t){for(let e in t)if(r[e]!==t[e])return!1;return!0}var C=n(n.flags.recipe,"StoreCook","#99bb15"),{values:It}=Object,Kt=(r,{name:t,type:e})=>_t(r,{name:t,type:e})?.[0],_t=(r,t)=>It(r.stores).filter(e=>Jt(e,t)),Jt=(r,t)=>{let{type:e,...s}=t;if(Gt(e,r?.meta.type))return W(r?.meta,s)},Gt=(r,t)=>{let e=["pojo","json"];return r===t||e.includes(r?.toLowerCase())||e.includes(t?.toLowerCase())},p=class{static async execute(t,e,s){return this.forEachStore(this.realizeStore,t,e,s)}static async evacipate(t,e,s){return this.forEachStore(this.derealizeStore,t,e,s)}static async forEachStore(t,e,s,o){return Promise.all(o.map(i=>t.call(this,e,s,i)))}static async realizeStore(t,e,s){let o,i=this.constructMeta(t,e,s),a=Kt(t,i);if(a)C(`realizeStore: mapping "${s.name}" to "${a.meta.name}"`);else if(C(`realizeStore: creating "${i.name}"`),a=p.createStore(t,i),o=i?.value,a.shouldPersist()){let c=await a.restore();o=c??o}e.addStore(i.name,a),o!==void 0&&(C("setting data to:",o),a.data=o)}static createStore(t,e){let s=t.createStore(e);return t.addStore(e.name,s),s}static async derealizeStore(t,e,s){C(`derealizeStore: derealizing "${s.name}"`),t.removeStore(s.name),e.removeStore(s.name)}static async removeStores(t,e,s){s.forEach(o=>{t.removeStore(o),e.removeStore(o)})}static constructMeta(t,e,s){let o={...s,arcid:e.id,uid:t.uid};return{...o,owner:o.uid,shareid:`${o.name}:${o.arcid}:${o.uid}`}}static specToMeta(t,e){return{name:t,type:e.$type,tags:e.$tags,value:e.$value}}};var Vt=n(n.flags.recipe,"ParticleCook","#5fa530"),f=class{static async execute(t,e,s){for(let o of s)await this.realizeParticle(t,e,o)}static async realizeParticle(t,e,s){Vt("realizedParticle:",s.id);let o=this.specToMeta(s.spec);return o.container||=s.container,t.bootstrapParticle(e,s.id,o)}static specToMeta(t){t.$bindings&&console.warn(`Particle '${t.$kind}' spec contains deprecated $bindings property (${JSON.stringify(t.$bindings)})`);let{$kind:e,$container:s,$staticInputs:o}=t,i=this.formatBindings(t.$inputs),a=this.formatBindings(t.$outputs);return{kind:e,staticInputs:o,inputs:i,outputs:a,container:s}}static formatBindings(t){return t?.map?.(e=>typeof e=="string"?{[e]:e}:e)}static async evacipate(t,e,s){return Promise.all(s.map(o=>this.derealizeParticle(t,e,o)))}static async derealizeParticle(t,e,s){e.removeHost(s.id)}static async removeParticles(t,e){e.forEach(s=>t.removeHost(s))}};var S=n(n.flags.recipe,"Chef","#087f23"),{assign:Qe,create:Xe}=Object;var lt=class{static async execute(t,e,s){if(s instanceof Promise){S.error("`arc` must be an Arc, not a Promise. Make sure `boostrapArc` is awaited.");return}S("|-->...| executing recipe: ",t);let o=new $(t);await p.execute(e,s,o.stores),await f.execute(e,s,o.particles),s.meta={...s.meta,...o.meta},S("|...-->| recipe complete: ",t.$meta??"")}static async evacipate(t,e,s){S("|-->...| evacipating recipe: ",t.$meta);let o=new $(t);await p.evacipate(e,s,o.stores),await f.evacipate(e,s,o.particles),S("|...-->| recipe evacipated: ",t.$meta)}static async executeAll(t,e,s){for(let o of t)await this.execute(o,e,s)}static async evacipateAll(t,e,s){for(let o of t)await this.evacipate(o,e,s)}};var ht=n(n.flags.recipe,"Chef","#087f23"),{assign:pt,create:rs}=Object,q=r=>Object.entries(r??Object),T=r=>Object.keys(r??Object),I=r=>Object.values(r??Object),Qt="main#graph",Xt=":",ut=class{runtime;arc;nodeTypes;storeTags;constructor(t,e,s){this.runtime=e,this.arc=s,this.nodeTypes={},this.storeTags={},T(t).forEach(o=>this.nodeTypes[o]=this.flattenNodeType(t[o]))}flattenNodeType(t,e){let s={};return T(t).forEach(o=>{o.startsWith("$")?s[o]={...s[o]||{},...t[o]}:pt(s,this.flattenParticleSpec(o,t[o],e))}),s}flattenParticleSpec(t,e,s){let o={[t]:{...e,$slots:{},...s&&{$container:s}}};return q(e.$slots||{}).forEach(([i,a])=>{pt(o,this.flattenNodeType(a,`${t}#${i}`)),o[t].$slots[i]={}}),o}async execute(t,e){let s=t.layout?.[e],o=[],i=[];return I(t.nodes).forEach(a=>{let c={};this.prepareStores(a,this.nodeTypes[a.type],o,c),this.prepareParticles(a,s,c,i)}),this.retagStoreSpecs(o),ht("Executing graph: ",o,i),await p.execute(this.runtime,this.arc,o),await this.realizeParticles(i),i.map(({id:a})=>a)}prepareStores({id:t,connections:e,props:s},o,i,a){q(o.$stores).forEach(([c,l])=>{a[c]=[];let v=this.constructId(t,c),$t=s?.[c]||l.$value,St=e?.[c];this.prepareStore(v,l,$t,St,i,a[c])})}prepareStore(t,{$type:e,$tags:s},o,i,a,c){i?i?.forEach?.(l=>this.addStore(l,s,c)):(a.push({name:t,type:e,value:o}),this.addStore(t,s,c))}addStore(t,e,s){s.push({id:t}),this.storeTags[t]=[...this.storeTags[t]||[],e]}retagStoreSpecs(t){t.forEach(e=>e.tags=this.storeTags[e.name])}resolveIoGroup(t,e){return t?.map(s=>{let{key:o,binding:i}=this.decodeBinding(s),a=(c,l)=>({[`${o}${l===0?"":l}`]:c});return e[i||o]?.map(({id:c},l)=>a(c,l))}).flat().filter(s=>s)}decodeBinding(t){if(typeof t=="string")return{key:t,binding:""};{let[e,s]=q(t)[0];return{key:e,binding:s}}}prepareParticles(t,e,s,o){let i=this.nodeTypes[t.type],a=this.constructId(t.id,"Container"),c=e?.[a]||Qt;this.getNodeParticleNames(i).forEach(l=>{o.push(this.prepareParticle(t,l,c,i,s))})}prepareParticle({id:t,props:e},s,o,i,a){let c=this.constructId(t,s),l=i[s];return{id:c,container:l.$container?`${t}:${l.$container}`:o,spec:{$kind:l.$kind,$staticInputs:e,$inputs:this.resolveIoGroup(l.$inputs,a),$outputs:this.resolveIoGroup(l.$outputs,a),$slots:{}}}}constructId(t,e){return`${t?`${t}${Xt}`:""}${e}`}async realizeParticles(t){let e=t.filter(({id:o})=>!this.arc.hosts[o]),s=t.filter(({id:o})=>this.arc.hosts[o]);await f.execute(this.runtime,this.arc,e),s.forEach(o=>this.updateParticleHosts(o))}updateParticleHosts({id:t,container:e,spec:s}){let o=this.arc.hosts[t];o.container!==e&&(o.meta.container=e,Object.values(this.arc.hosts).forEach(a=>a.rerender()));let i=f.specToMeta(s);i.container=e,d(i,o.meta)||(o.meta=i,this.arc.updateHost(o))}async evacipate(t){ht("Evacipating graph",t),await p.removeStores(this.runtime,this.arc,this.getStoreNames(t)),await f.removeParticles(this.arc,this.getParticleNames(t))}getParticleNames(t){let e=[];return I(t.nodes).forEach(({id:s,type:o})=>{this.getNodeParticleNames(this.nodeTypes[o]).forEach(i=>e.push(this.constructId(s,i)))}),e}getNodeParticleNames(t){return T(t).filter(e=>!e.startsWith("$"))}getStoreNames(t){let e=[];return I(t.nodes).forEach(({id:s,type:o})=>{let i=this.nodeTypes[o];T(i.$stores).forEach(a=>{e.push(this.constructId(s,a))})}),e}};var yt={};G(yt,{fetchParticleCode:()=>dt,maybeFetchParticleCode:()=>gt,pathForKind:()=>mt,requireParticleBaseCode:()=>P,requireParticleImplCode:()=>te});var ft=class{map;constructor(r){this.map={},this.setRoot(r)}add(r){Object.assign(this.map,r||{})}resolve(r){let t;do r=this._resolve(t=r);while(t!==r);return r}_resolve(r){let t=r.split("/"),e=t.shift();return[this.map[e]||e,...t].join("/")}setRoot(r){r.length&&r[r.length-1]==="/"&&(r=r.slice(0,-1)),this.add({$root:r,$arcs:r})}getAbsoluteHereUrl(r,t){let e=r.url.split("/").slice(0,-(t??1)).join("/");if(globalThis?.document){let s=document.URL;s[s.length-1]!=="/"&&(s=`${s.split("/").slice(0,-1).join("/")}/`);let o=new URL(e,s).href;return o[o.length-1]==="/"&&(o=o.slice(0,-1)),o}else return e}},Yt=import.meta.url.split("/").slice(0,-3).join("/"),x=globalThis.Paths=new ft(Yt);x.add(globalThis.config?.paths);var K=n(n.flags.code,"code","gold","#333"),Zt="$arcs/core/Particle.js",te=async(r,t)=>{let e=t?.code||await dt(r);return e.slice(e.indexOf("({"))},dt=async r=>{if(r)return await gt(r);K.error("fetchParticleCode: empty 'kind'")},gt=async r=>{let t=mt(r);try{let e=await fetch(t);if(e.ok)return await e.text();throw""}catch{K.error(`could not locate implementation for particle "${r}" [${t}]`)}},mt=r=>r?(!"$./".includes(r[0])&&!r.includes("://")&&(r=`$library/${r}`),r?.split("/").pop().includes(".")||(r=`${r}.js`),x.resolve(r)):"404",P=async r=>{if(!P.source){let t=x.resolve(r||Zt);K("particle base code path: ",t);let s=await(await fetch(t)).text()+`
//# sourceURL=`+t+`
`;P.source=s.replace(/export /g,"")}return P.source};P.source=null;var _={};G(_,{PathMapper:()=>ft,Paths:()=>x,arand:()=>k,async:()=>re,asyncTask:()=>oe,computeAgeString:()=>ee,debounce:()=>se,deepCopy:()=>u,deepEqual:()=>d,deepUndefinedToNull:()=>tt,irand:()=>E,key:()=>jt,logFactory:()=>n,makeId:()=>m,matches:()=>W,prob:()=>Ct,shallowMerge:()=>Ot,shallowUpdate:()=>wt});var ee=(r,t)=>{let e=Math.round((t-r)/1e3);if(isNaN(e))return"\u2022";let s="";return e<60?(e>1&&(s="s"),`${e} second${s} ago`):(e=Math.round(e/60),e<60?(e>1&&(s="s"),`${e} minute${s} ago`):(e=Math.round(e/60),e<24?(e>1&&(s="s"),`${e} hour${s} ago`):(e=Math.round(e/24),e<30?(e>1&&(s="s"),`${e} day${s} ago`):(e=Math.round(e/30),e<12?(e>1&&(s="s"),`${e} month${s} ago`):(e=Math.round(e/12),e>1&&(s="s"),`${e} year${s} ago`)))))};var se=(r,t,e)=>{if(r&&clearTimeout(r),t&&e)return setTimeout(t,e)},re=r=>async(...t)=>{await Promise.resolve(),r(...t)},oe=(r,t)=>{setTimeout(r,t??0)};var{logFactory:Ss,Paths:ie}=_;var ae=import.meta.url.split("/").slice(0,-1).join("/");ie.setRoot(ae);export{O as Arc,lt as Chef,A as DataStore,M as Decorator,h as EventEmitter,ut as Graphinator,g as Host,$ as Parser,f as ParticleCook,ie as Paths,y as Runtime,j as Store,p as StoreCook,yt as code,Ss as logFactory,_ as utils};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file or at
 * https://developers.google.com/open-source/licenses/bsd
 */
/**
 * @license
 * Copyright (c) 2022 Google LLC All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
//# sourceMappingURL=arcs.min.js.map
