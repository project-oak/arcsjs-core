var et=Object.defineProperty;var Dt=(s,t,e)=>t in s?et(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var Bt=(s,t)=>()=>(s&&(t=s(s=0)),t);var st=(s,t)=>{for(var e in t)et(s,e,{get:t[e],enumerable:!0})};var w=(s,t,e)=>(Dt(s,typeof t!="symbol"?t+"":t,e),e);var wt={};st(wt,{Particle:()=>B,ParticleApi:()=>Y});var xt,St,vt,he,X,pe,ue,T,Q,fe,D,de,Y,me,B,Pt=Bt(()=>{({create:xt,assign:St,keys:vt,values:he,entries:X,defineProperty:pe,setPrototypeOf:ue}=Object),T=globalThis.scope??{},{log:Q,timeout:fe}=T,D=()=>xt(null),de=new class{get empty(){return this.length===0}get data(){return this}get pojo(){return this.data}get json(){return JSON.stringify(this.pojo)}get pretty(){return JSON.stringify(this.pojo,null,"  ")}get keys(){return vt(this.data)}get length(){return vt(this.data).length}get values(){return he(this.data)}get entries(){return X(this.data)}set(s,t){this.data[s]=t}setByIndex(s,t){this.data[this.keys[s]]=t}add(...s){s.forEach(t=>this.data[T.makeKey()]=t)}push(...s){this.add(...s)}remove(s){X(this.data).find(([t,e])=>{if(e===s)return delete this.data[t],!0})}has(s){return this.data[s]!==void 0}get(s){return this.getByKey(s)}getByKey(s){return this.data[s]}getByIndex(s){return this.data[this.keys[s]]}delete(s){delete this.data[s]}deleteByIndex(s){delete this.data[this.keys[s]]}assign(s){St(this.data,s)}map(s){return this.values.map(s)}toString(){return this.pretty}},Y=class{get template(){return null}shouldUpdate(t,e){return!0}async update(t,e,r){return null}shouldRender(t,e){return!0}render(t,e){return null}},me=s=>{let t=s;return{get:()=>t,set:e=>t=e}},B=class{pipe;impl;internal;constructor(t,e,r){this.pipe=e,this.impl=xt(t),pe(this,"internal",me(D())),this.internal.$busy=0,this.internal.beStateful=!0,this.internal.state=D()}get log(){return this.pipe?.log||Q}get template(){return this.impl?.template}get config(){return{template:this.template}}set inputs(t){this.internal.inputs=t,this.invalidateInputs()}get inputs(){return this.internal.inputs}get state(){return this.internal.state}async service(t){return this.pipe?.service?.(t)}invalidateInputs(){this.internal.$propChanged=!0,this.invalidate()}invalidate(){this.internal.validator||(this.internal.validator=fe(this.validate.bind(this),1))}async(t){return Promise.resolve().then(t.bind(this))}async validate(){if(this.internal.validator){try{this.internal.$validateAfterBusy=this.internal.$busy,this.internal.$busy||(this.internal.beStateful||(this.internal.state=D()),this.internal.inputs=this.validateInputs(),await this.maybeUpdate())}catch(t){Q.error(t)}this.internal.validator=null,this.internal.$propChanged=!1}}validateInputs(){let t=St(D(),this.inputs);return X(t).forEach(([e,r])=>{r&&typeof r=="object"&&(Array.isArray(r)||(r=ue({...r},de)),t[e]=r)}),t}implements(t){return typeof this.impl?.[t]=="function"}async maybeUpdate(){await this.checkInit()&&(this.canUpdate()||this.outputData(null),await this.shouldUpdate(this.inputs,this.state)&&this.update())}async checkInit(){return this.internal.initialized||(this.internal.initialized=!0,this.implements("initialize")&&await this.asyncMethod(this.impl.initialize)),!0}canUpdate(){return this.implements("update")}async shouldUpdate(t,e){return!this.impl?.shouldUpdate||await this.impl.shouldUpdate(t,e)!==!1}update(){this.asyncMethod(this.impl?.update)}outputData(t){this.pipe?.output?.(t,this.maybeRender())}maybeRender(){if(this.template){let{inputs:t,state:e}=this.internal;if(this.impl?.shouldRender?.(t,e)!==!1)return this.implements("render")?this.impl.render(t,e):{...t,...e}}}async handleEvent({handler:t,data:e}){let r=this.impl?.[t];r&&(this.internal.inputs.eventlet=e,await this.asyncMethod(r.bind(this.impl),{eventlet:e}),this.internal.inputs.eventlet=null)}async asyncMethod(t,e){if(t){let{inputs:r,state:i}=this.internal,a={service:async c=>this.service(c),invalidate:()=>this.invalidate(),output:async c=>this.outputData(c)},o=t.bind(this.impl,r,i,{...a,...e});this.outputData(await this.try(o)),!this.internal.$busy&&this.internal.$validateAfterBusy&&this.invalidate()}}async try(t){this.internal.$busy++;try{return await t()}catch(e){Q.error(e)}finally{this.internal.$busy--}}};T.harden(globalThis);T.harden(B)});var p=class{listeners={};getEventListeners(t){return this.listeners[t]||(this.listeners[t]=[])}fire(t,...e){let r=this.getEventListeners(t);r?.forEach&&r.forEach(i=>i(...e))}listen(t,e,r){return this.getEventListeners(t).push(e),e._name=r||"(unnamed listener)",e}unlisten(t,e){let r=this.getEventListeners(t),i=typeof e=="string"?r.findIndex(a=>a._name===e):r.indexOf(e);i>=0?r.splice(i,1):console.warn("failed to unlisten from",t)}};var rt=["log","group","groupCollapsed","groupEnd","dir"],it=["warn","error"];var{fromEntries:at}=Object,nt=(s,t,e,r,i="log")=>{if(!s)return()=>{};if(i==="dir")return console.dir.bind(console);let a=`background: ${e||"gray"}; color: ${r||"white"}; padding: 1px 6px 2px 7px; border-radius: 6px 0 0 6px;`;return console[i].bind(console,`%c${t}`,a)},n=(s,t,e="",r="")=>{let i=at(rt.map(h=>[h,nt(s,t,e,r,h)])),a=at(it.map(h=>[h,nt(!0,t,e,r,h)])),o={...i,...a},c=o.log;return Object.assign(c,o),c};n.flags=globalThis.config?.logFlags||{};var Tt=s=>n(n.flags.arc,`Arc (${s})`,"slateblue"),{assign:Mt,keys:A,entries:ot,create:At}=Object,P=s=>Object.values(s),z=()=>At(null),O=class extends p{log;id;meta;stores;hosts;surface;composer;hostService;constructor(t,e,r){super(),this.id=t,this.meta=e,this.surface=r,this.hosts=z(),this.stores=z(),this.log=Tt(t)}async addHost(t,e){return await this.ensureComposer(),this.hosts[t.id]=t,t.arc=this,this.updateHost(t),t}async ensureComposer(){!this.composer&&this.surface&&(this.composer=await this.surface.createComposer("root"),this.composer.onevent=this.onevent.bind(this))}rerender(){P(this.hosts).forEach(t=>t.rerender())}removeHost(t){this.hosts[t]?.detach(),delete this.hosts[t]}addStore(t,e){e&&!this.stores[t]&&(this.stores[t]=e,e.listen("change",()=>this.storeChanged(t,e),this.id))}removeStore(t){let e=this.stores[t];e&&e.unlisten("change",this.id),delete this.stores[t]}storeChanged(t,e){this.log(`storeChanged: "${t}"`);let r=i=>i&&i.some(a=>P(a)[0]==t||A(a)[0]==t);P(this.hosts).forEach(i=>{let a=i.meta?.inputs;(a==="*"||r(a))&&(this.log(`host "${i.id}" has interest in "${t}"`),this.updateHost(i))}),this.fire("store-changed",t)}updateParticleMeta(t,e){let r=this.hosts[t];r.meta=e,this.updateHost(r)}updateHost(t){t.inputs=this.computeInputs(t)}computeInputs(t){let e=z(),r=t.meta?.inputs;if(r==="*")ot(this.stores).forEach(([i,a])=>e[i]=a.pojo);else{let i=t.meta?.staticInputs;Mt(e,i),r&&(r.forEach(a=>this.computeInput(ot(a)[0],e)),this.log(`computeInputs(${t.id}) =`,e))}return e}computeInput([t,e],r){let i=e||t,a=this.stores[i];a&&(r[t]=a.pojo)}assignOutputs({id:t,meta:e},r){let i=A(r);e?.outputs&&i.length&&(i.forEach(a=>this.assignOutput(a,r[a],e.outputs)),this.log(`[end][${t}] assignOutputs:`,r))}assignOutput(t,e,r){if(e!==void 0){let i=this.findOutputByName(r,t)||t,a=this.stores[i];a?(this.log(`assignOutputs: "${t}" is dirty, updating Store "${i}"`,e),a.data=e):r?.[t]&&this.log.warn(`assignOutputs: no "${i}" store for output "${t}"`)}}findOutputByName(t,e){let r=t?.find(i=>A(i||0)[0]===e);if(r)return P(r)[0]}async render(t){this.composer&&this.composer.render(t)}onevent(t,e){let r=this.hosts[t];r&&r.handleEvent(e)}async service(t,e){let r=await this.surface?.service(e);return r===void 0&&(r=this.hostService?.(t,e)),r}};var zt=(s,t)=>{let e=t;if(t){if(Array.isArray(t)){Array.isArray(s)||(s=[]);for(let i=0;i<t.length;i++){let a=t[i];s[i]!==a&&(s[i]=a)}let r=s.length-t.length;r>0&&s.splice(t.length,r)}else if(typeof t=="object"){e=s&&typeof s=="object"?s:Object.create(null);let r={};Object.keys(t).forEach(i=>{e[i]=t[i],r[i]=!0}),Object.keys(e).forEach(i=>{r[i]||delete e[i]})}}return e},Ut=(s,t)=>{if(t==null)return null;if(typeof t=="object"){let e=s&&typeof s=="object"?s:Object.create(null);return Object.keys(t).forEach(r=>e[r]=t[r]),e}return t};function u(s){if(s){if(Array.isArray(s))return s.map(t=>u(t));if(typeof s=="object"){let t=Object.create(null);return Object.entries(s).forEach(([e,r])=>{t[e]=u(r)}),t}else return s}else return s}var f=(s,t)=>{let e=typeof s;if(e!==typeof t)return!1;if(e==="object"&&s&&t){let r=Object.getOwnPropertyNames(s),i=Object.getOwnPropertyNames(t);return r.length==i.length&&!r.some(a=>!f(s[a],t[a]))}return s===t},ct=s=>s===void 0?null:(s&&typeof s=="object"&&Object.getOwnPropertyNames(s).forEach(e=>{let r=s[e];r===void 0?delete s[e]:ct(r)}),s);var{floor:lt,pow:Lt,random:U}=Math,Nt=s=>lt((1+U()*9)*Lt(10,s-1)),j=s=>lt(U()*s),L=s=>s[j(s.length)],Rt=s=>Boolean(U()<s);var N=n(n.flags.decorator,"Decorator","plum"),{values:Ht,entries:pt}=Object,ht={},R={setOpaqueData(s,t){return ht[s]=t,s},getOpaqueData(s){return ht[s]},maybeDecorateModel(s,t){return s&&!Array.isArray(s)&&Ht(s).forEach(e=>{e&&typeof e=="object"&&(e.models?(N("applying decorator(s) to list:",e),this.maybeDecorateItem(e,t)):(s?.filter||s?.decorator||s?.collateBy)&&(N("scanning for lists in sub-model:",e),this.maybeDecorateModel(e,t)))}),s},maybeDecorateItem(s,t){let e=typeof s.models=="string"?this.getOpaqueData(s.models):s.models;e&&(e=It(e,s.decorator,t),e=Kt(e,s.filter,t.impl),e=qt(e,s),s.models=e)}},It=(s,t,e)=>{t=e.impl[t]??t;let{inputs:r,state:i}=e.internal;if(t){let a=Object.freeze(u(r)),o=Object.freeze(u(i));s=s.map(c=>{c.privateData=c.privateData||{};let h=Object.freeze(u(c)),y=t(h,a,o);return c.privateData=y.privateData,{...y,...c}}),s.sort(Wt("sortKey")),N("decoration was performed")}return s},Kt=(s,t,e)=>(t=e[t]??t,t&&s&&(s=s.filter(t)),s),qt=(s,t)=>(pt(t).forEach(([e,r])=>{if(r?.collateBy){let i=Vt(s,r.collateBy);s=_t(i,e,r.$template)}}),s),Wt=s=>(t,e)=>Jt(String(t[s]).toLowerCase(),String(e[s]).toLowerCase()),Jt=(s,t)=>s<t?-1:s>t?1:0,Vt=(s,t)=>{let e={};return s.forEach(r=>{let i=r[t];i&&(e[i]||(e[i]=[])).push(r)}),e},_t=(s,t,e)=>pt(s).map(([r,i])=>({key:r,[t]:{models:i,$template:e},single:i.length===1,...i?.[0]}));var{entries:ut,keys:Gt}=Object,Qt=s=>n(n.flags.host,`Host (${s})`,L(["#5a189a","#51168b","#48137b","#6b2fa4","#7b46ae","#3f116c"])),b=class extends p{arc;id;lastOutput;lastPacket;lastRenderModel;log;meta;particle;constructor(t){super(),this.log=Qt(t),this.id=t}onevent(t){this.arc?.onevent(t)}installParticle(t,e){this.particle&&this.detachParticle(),t&&(this.particle=t,this.meta=e||this.meta)}get container(){return this.meta?.container||"root"}detach(){this.detachParticle(),this.arc=null}detachParticle(){this.particle&&(this.render({$clear:!0}),this.particle=null,this.meta=null)}async service(t){return t?.decorate?R.maybeDecorateModel(t.model,this.particle):this.arc?.service(this,t)}output(t,e){t&&(this.lastOutput=t,this.arc?.assignOutputs(this,t)),this.template&&(R.maybeDecorateModel(e,this.particle),this.lastRenderModel={...e},this.render(e))}rerender(){this.lastRenderModel&&this.render(this.lastRenderModel)}render(t){let{id:e,container:r,template:i}=this,o={id:e,container:r,content:{model:t,template:i}};this.arc?.render(o),this.lastPacket=o}set inputs(t){if(this.particle&&t){let e=this.particle.internal.inputs;this.dirtyCheck(t,e,this.lastOutput)?(this.particle.inputs=u({...this.meta?.staticInputs,...t}),this.fire("inputs-changed")):this.log("inputs are uninteresting, skipping update")}}dirtyCheck(t,e,r){let i=([a,o])=>r?.[a]&&!f(r[a],o)||!f(e?.[a],o);return!e||ut(t).length!==this.lastInputsLength(e)||ut(t).some(i)}lastInputsLength(t){return Gt(t).filter(e=>!this.meta?.staticInputs?.[e]&&e!=="eventlet").length}get config(){return this.particle?.config}get template(){return this.config?.template}invalidate(){this.particle?.invalidate()}handleEvent(t){return this.particle?.handleEvent(t)}};var{create:Xt,keys:Yt}=Object,{stringify:ft,parse:dt}=JSON,H=class extends p{privateData;constructor(){super()}setPrivateData(t){this.privateData=t}set data(t){this.setPrivateData(t)}get data(){return this.privateData}toString(){return this.pretty}get isObject(){return this.data&&typeof this.data=="object"}get pojo(){return this.data}get json(){return ft(this.data)}set json(t){let e=null;try{e=dt(t)}catch{}this.data=e}get pretty(){let t={},e=this.pojo;return Yt(e).sort().forEach(r=>t[r]=e[r]),ft(t,null,"  ")}},I=class extends H{change(t){t(this),this.doChange()}doChange(){this.fire("change",this),this.onChange(this)}onChange(t){}set data(t){this.change(e=>e.setPrivateData(t))}get data(){return this.privateData}set(t,e){this.data||this.setPrivateData(Xt(null)),e!==void 0?this.change(r=>r.data[t]=e):this.delete(t)}delete(t){this.change(e=>delete e.data[t])}},K=class extends I{meta;constructor(t){super(),this.meta={...t}}toString(){return`${JSON.stringify(this.meta,null,"  ")}, ${this.pretty}`}get tags(){return this.meta.tags??(this.meta.tags=[])}is(...t){return t.every(e=>this.tags.includes(e))}isCollection(){return this.meta.type?.[0]==="["}shouldPersist(){return this.is("persisted")&&!this.is("volatile")}async doChange(){return this.persist(),super.doChange()}async persist(){}async restore(){}save(){return this.json}load(t,e){let r=e;try{t&&(r=dt(t))}catch{}r!==void 0&&(this.data=r)}},E=class extends K{};var C=(s,t,e)=>{s=s||2,t=t||2,e=e||"-";let r=Math.pow(10,t-1),i=Math.pow(10,t)-r,a=[];for(let o=0;o<s;o++)a.push(`${j(i-r)+r}`);return a.join(e)};var mt=n(n.flags.runtime,"runtime","#873600"),gt={},q={},{keys:Zt}=Object,$=class extends p{log;uid;nid;arcs;stores;peers;shares;endpoint;network;surfaces;persistor;prettyUid;constructor(t){t=t||"user",super(),this.arcs={},this.surfaces={},this.stores={},this.peers=new Set,this.shares=new Set,this.setUid(t),this.log=n(n.flags.runtime,`runtime:[${this.prettyUid}]`,"#873600")}setUid(t){this.uid=t,this.nid=`${t}:${C(1,2)}`,this.prettyUid=t.substring(0,t.indexOf("@")+1)||t}async bootstrapArc(t,e,r,i){let a=new O(t,e,r);return a.hostService=this.serviceFactory(i),await this.addArc(a),a}serviceFactory(t){return async(e,r)=>t.handle(this,e,r)}async bootstrapParticle(t,e,r){let i=new b(e);await this.marshalParticle(i,r);let a=t.addHost(i);return mt("bootstrapped particle",e),a}addSurface(t,e){this.surfaces[t]=e}getSurface(t){return this.surfaces[t]}addArc(t){let{id:e}=t;if(e&&!this.arcs[e])return this.arcs[e]=t;throw`arc has no id, or id "${e}" is already in use`}removeArc(t){let{id:e}=t;if(!e||!this.arcs[e])throw e?`id "${e}" is not in use`:"arc has no id";delete this.arcs[e]}async marshalParticle(t,e){let r=await this.createParticle(t,e.kind);t.installParticle(r,e)}async installParticle(t,e,r){if(this.log("installParticle",r,e,t.id),r=r||C(),t.hosts[r]){let a=1;for(;t.hosts[`${r}-${a}`];a++);r=`${r}-${a}`}let i=new b(r);return await this.marshalParticle(i,e),t.addHost(i),i}addStore(t,e){e.marshal&&e.marshal(this),e.persist=async()=>this.persistStore(t,e),e.restore=async()=>this.restoreStore(t,e);let r=`${this.nid}:${t}-changed`,i=this.storeChanged.bind(this,t);e.listen("change",i,r),this.stores[t]=e,this.maybeShareStore(t)}async persistStore(t,e){if(e.shouldPersist())return this.log(`persistStore "${t}"`),this.persistor.persist?.(t,e)}async restoreStore(t,e){if(e.shouldPersist())return this.log(`restoreStore "${t}"`),this.persistor.restore?.(t)}storeChanged(t,e){this.log("storeChanged",t),this.network?.invalidatePeers(t),this.onStoreChange(t,e),this.fire("store-changed",{storeId:t,store:e})}onStoreChange(t,e){}do(t,e){e(this.stores[t])}removeStore(t){this.do(t,e=>{e?.unlisten("change",`${this.nid}:${t}-changed`)}),delete this.stores[t]}maybeShareStore(t){this.do(t,e=>{e?.is("shared")&&this.shareStore(t)})}addPeer(t){this.peers.add(t),[...this.shares].forEach(e=>this.maybeShareStoreWithPeer(e,t))}shareStore(t){this.shares.add(t),[...this.peers].forEach(e=>this.maybeShareStoreWithPeer(t,e))}maybeShareStoreWithPeer(t,e){this.do(t,r=>{let i=this.uid.replace(/\./g,"_");(!r.is("private")||e.startsWith(i))&&this.shareStoreWithPeer(t,e)})}shareStoreWithPeer(t,e){this.network?.shareStore(t,e)}async createParticle(t,e){try{return(await this.marshalParticleFactory(e))(t)}catch(r){mt.error(`createParticle(${e}):`,r)}}async marshalParticleFactory(t){return gt[t]??this.lateBindParticle(t)}lateBindParticle(t,e){return $.registerParticleFactory(t,$?.particleIndustry(t,{...$.particleOptions,code:e}))}static registerParticleFactory(t,e){return gt[t]=e}requireStore(t){let e=this.stores[t.name];return e||(e=this.createStore(t),this.addStore(t.name,e)),e}createStore(t){let e=Zt(q).find(i=>t.tags?.includes?.(i)),r=q[String(e)]||E;return new r(t)}static registerStoreClass(t,e){q[t]=e}},d=$;w(d,"securityLockdown"),w(d,"particleIndustry"),w(d,"particleOptions");var W=n(n.flags.recipe,"flan","violet"),{entries:te,create:ee}=Object,v=class{stores;particles;slots;meta;constructor(t){this.stores=[],this.particles=[],this.slots=[],this.meta=ee(null),t&&this.parse(t)}parse(t){let e=this.normalize(t);return this.parseSlotSpec(e,"root",""),this}normalize(t){if(typeof t!="object")throw Error("recipe must be an Object");return t}parseSlotSpec(t,e,r){for(let i in t)switch(i){case"$meta":this.meta={...this.meta,...t.$meta};break;case"$stores":this.parseStoresNode(t.$stores);break;default:{let a=r?`${r}#${e}`:e;this.parseParticleSpec(a,i,t[i]);break}}}parseStoresNode(t){for(let e in t)this.parseStoreSpec(e,t[e])}parseStoreSpec(t,e){if(this.stores.find(i=>i.name===t)){W("duplicate store name");return}let r={name:t,type:e.$type,tags:e.$tags,value:e.$value};this.stores.push(r)}parseParticleSpec(t,e,r){if(!r.$kind)throw W.warn('parseParticleSpec: malformed spec has no "kind":',r),Error();if(this.particles.find(i=>i.id===e)){W("duplicate particle name");return}this.particles.push({id:e,container:t,spec:r}),r.$slots&&this.parseSlotsNode(r.$slots,e)}parseSlotsNode(t,e){te(t).forEach(([r,i])=>this.parseSlotSpec(i,r,e))}};function J(s,t){for(let e in t)if(s[e]!==t[e])return!1;return!0}var V=n(n.flags.recipe,"StoreCook","#99bb15"),{values:se}=Object,re=(s,t)=>se(s.stores).filter(e=>J(e?.meta,t)),ie=(s,{name:t,type:e})=>re(s,{name:t,type:e})?.[0],F=class{static async execute(t,e,r){return this.forEachStore(this.realizeStore,t,e,r)}static async evacipate(t,e,r){return this.forEachStore(this.derealizeStore,t,e,r)}static async forEachStore(t,e,r,i){return Promise.all(i.map(a=>t.call(this,e,r,a)))}static async realizeStore(t,e,r){let i=this.constructMeta(t,e,r),a=i?.value,o=ie(t,i);if(o)V(`realizeStore: mapped "${r.name}" to "${o.meta.name}"`);else if(o=t.createStore(i),V(`realizeStore: created "${i.name}"`),t.addStore(i.name,o),o.shouldPersist()){let c=await o.restore();a=c===void 0?a:c}a!==void 0&&(V("setting data to:",a),o.data=a),e.addStore(i.name,o)}static async derealizeStore(t,e,r){t.removeStore(r.$name),e.removeStore(r.$name)}static constructMeta(t,e,r){let i={...r,arcid:e.id,uid:t.uid};return{...i,owner:i.uid,shareid:`${i.name}:${i.arcid}:${i.uid}`}}};var ae=n(n.flags.recipe,"ParticleCook","#5fa530"),x=class{static async execute(t,e,r){for(let i of r)await this.realizeParticle(t,e,i)}static async realizeParticle(t,e,r){ae("realizedParticle:",r.id);let i=this.specToMeta(r.spec);return i.container||=r.container,t.bootstrapParticle(e,r.id,i)}static specToMeta(t){t.$bindings&&console.warn(`Particle '${t.$kind}' spec contains deprecated $bindings property (${JSON.stringify(t.$bindings)})`);let{$kind:e,$container:r,$staticInputs:i}=t,a=this.formatBindings(t.$inputs),o=this.formatBindings(t.$outputs);return{kind:e,staticInputs:i,inputs:a,outputs:o,container:r}}static formatBindings(t){return t?.map?.(e=>typeof e=="string"?{[e]:e}:e)}static async evacipate(t,e,r){return Promise.all(r.map(i=>this.derealizeParticle(t,e,i)))}static async derealizeParticle(t,e,r){e.removeHost(r.id)}};var S=n(n.flags.recipe,"Chef","#087f23"),yt=class{static async execute(t,e,r){if(r instanceof Promise){S.error("`arc` must be an Arc, not a Promise. Make sure `boostrapArc` is awaited.");return}S("|-->...| executing recipe: ",t.$meta??"");let i=new v(t);await F.execute(e,r,i.stores),await x.execute(e,r,i.particles),r.meta={...r.meta,...i.meta},S("|...-->| recipe complete: ",t.$meta??"")}static async evacipate(t,e,r){S("|-->...| evacipating recipe: ",t.$meta);let i=new v(t);await x.evacipate(e,r,i.particles),S("|...-->| recipe evacipated: ",t.$meta)}static async executeAll(t,e,r){for(let i of t)await this.execute(i,e,r)}static async evacipateAll(t,e,r){return Promise.all(t?.map(i=>this.evacipate(i,e,r)))}};var bt=class{map;constructor(s){this.map={},this.setRoot(s)}add(s){Object.assign(this.map,s||{})}resolve(s){let t=s.split("/"),e=t.shift();return[this.map[e]||e,...t].join("/")}setRoot(s){s.length&&s[s.length-1]==="/"&&(s=s.slice(0,-1)),this.add({$root:s,$arcs:s})}getAbsoluteHereUrl(s,t){let e=s.url.split("/").slice(0,-(t??1)).join("/");if(globalThis?.document){let r=document.URL;r[r.length-1]!=="/"&&(r=`${r.split("/").slice(0,-1).join("/")}/`);let i=new URL(e,r).href;return i[i.length-1]==="/"&&(i=i.slice(0,-1)),i}else return e}},ne=import.meta.url.split("/").slice(0,-3).join("/"),m=globalThis.Paths=new bt(ne);m.add(globalThis.config?.paths);var _=n(n.flags.code,"code","gold"),oe="$arcs/js/core/Particle.js",k=async s=>{if(!k.source){let t=m.resolve(s||oe);_("particle base code path: ",t);let r=await(await fetch(t)).text()+`
//# sourceURL=`+t+`
`;k.source=r.replace(/export /g,"")}return k.source};k.source=null;var $t=async(s,t)=>{let e=t?.code||await ce(s);return e.slice(e.indexOf("({"))},ce=async s=>{if(s)return await le(s);_.error("fetchParticleCode: empty 'kind'")},le=async s=>{let t=G(s);try{return await(await fetch(t)).text()}catch{_.error(`could not locate implementation for particle "${s}" [${t}]`)}},G=s=>s?(!"$./".includes(s[0])&&!s.includes("://")&&(s=`$library/${s}`),s?.split("/").pop().includes(".")||(s=`${s}.js`),m.resolve(s)):"404";var M=n(n.flags.isolation,"vanilla","goldenrod"),jt=s=>s;globalThis.harden=jt;globalThis.scope={harden:jt};var ge=()=>`i${Math.floor((1+Math.random()*9)*1e14)}`,ye=async(s,t)=>new Promise(e=>setTimeout(()=>e(s()),t)),be=s=>{try{M(f);let e={...{log:M,resolve:Et,html:Ct,makeKey:ge,deepEqual:f,timeout:ye},...s?.injections};Object.assign(globalThis.scope,e),Object.assign(globalThis,e)}finally{}},Et=m.resolve.bind(m),Ct=(s,...t)=>`${s[0]}${t.map((e,r)=>`${e}${s[r+1]}`).join("")}`.trim(),$e=async(s,t)=>{let{Particle:e}=await Promise.resolve().then(()=>(Pt(),wt)),r=await ve(s,t),i=Ee(s),a={log:i,resolve:Et,html:Ct,...t?.injections},o=r(a);return h=>{let y={log:i,output:h.output.bind(h),service:h.service.bind(h)};return new e(o,y,!0)}},ve=async(s,t)=>{let e=await $t(s,t),r=(0,eval)(e);return typeof r=="object"&&(r=Oe(r,s),M(`repackaged factory:
`,r)),globalThis.harden(r)},{assign:xe,keys:Se,entries:we,values:Ot,create:Pe}=Object;globalThis.SafeObject={create:Pe,assign:xe,keys(s){return s?Se(s):[]},values(s){return s?Ot(s):[]},entries(s){return s?we(s):[]},mapBy(s,t){return s?Ot(s).reduce((e,r)=>(e[t(r)]=r,e),{}):{}}};var Oe=(s,t)=>{let{constNames:e,rewriteConsts:r,funcNames:i,rewriteFuncs:a}=je(s),o=`{${[...e,...i]}}`,c=`
({log, ...utils}) => {
// protect utils
globalThis.harden(utils);
// these are just handy
const {assign, keys, entries, values, create, mapBy} = globalThis.SafeObject;
// declarations
${[...r,...a].join(`

`)}
// hardened Object (map) of declarations,
// suitable to be a prototype
return globalThis.harden(${o});
// name the file for debuggers
//# sourceURL=sandbox/${G(t).split("/").pop()}
};
  `;return M(`rewritten:

`,c),(0,eval)(c)},je=s=>{let t=Object.entries(s),e=([l,g])=>typeof g=="function",r=([l,g])=>l=="harden"||l=="globalThis",i=t.filter(l=>e(l)&&!r(l)),a=i.map(([l,g])=>{let tt=g?.toString?.()??"",Ft=tt.includes("async"),kt=tt.replace("async ","").replace("function ","");return`${Ft?"async":""} function ${kt};`}),o=i.map(([l])=>l),c=t.filter(l=>!e(l)&&!r(l)),h=c.map(([l,g])=>`const ${l} = \`${g}\`;`);return{constNames:c.map(([l])=>l),rewriteConsts:h,funcNames:o,rewriteFuncs:a}},Ee=s=>{let t=n(n.flags.particles,s,"#002266");return(e,...r)=>{let a=(e?.stack?.split(`
`)?.slice(1,2)||new Error().stack?.split(`
`).slice(2,3)).map(o=>o.replace(/\([^()]*?\)/,"").replace(/ \([^()]*?\)/,"").replace("<anonymous>, <anonymous>","").replace("Object.","").replace("eval at :","").replace(/\(|\)/g,"").replace(/\[[^\]]*?\] /,"").replace(/at (.*) (\d)/,'at "$1" $2')).reverse().join(`
`).trim();e?.message?t.error(e.message,...r,`(${a})`):t(e,...r,`(${a})`)}};d.particleIndustry=$e;d.securityLockdown=be;var Z={};st(Z,{PathMapper:()=>bt,Paths:()=>m,arand:()=>L,async:()=>ke,asyncTask:()=>De,computeAgeString:()=>Ce,debounce:()=>Fe,deepCopy:()=>u,deepEqual:()=>f,deepUndefinedToNull:()=>ct,irand:()=>j,key:()=>Nt,logFactory:()=>n,makeId:()=>C,matches:()=>J,prob:()=>Rt,shallowMerge:()=>Ut,shallowUpdate:()=>zt});var Ce=(s,t)=>{let e=Math.round((t-s)/1e3);if(isNaN(e))return"\u2022";let r="";return e<60?(e>1&&(r="s"),`${e} second${r} ago`):(e=Math.round(e/60),e<60?(e>1&&(r="s"),`${e} minute${r} ago`):(e=Math.round(e/60),e<24?(e>1&&(r="s"),`${e} hour${r} ago`):(e=Math.round(e/24),e<30?(e>1&&(r="s"),`${e} day${r} ago`):(e=Math.round(e/30),e<12?(e>1&&(r="s"),`${e} month${r} ago`):(e=Math.round(e/12),e>1&&(r="s"),`${e} year${r} ago`)))))};var Fe=(s,t,e)=>{if(s&&clearTimeout(s),t&&e)return setTimeout(t,e)},ke=s=>async(...t)=>{await Promise.resolve(),s(...t)},De=(s,t)=>{setTimeout(s,t??0)};var{logFactory:Ws,Paths:Be}=Z;var Te=import.meta.url.split("/").slice(0,-1).join("/");Be.setRoot(Te);export{O as Arc,yt as Chef,H as DataStore,R as Decorator,p as EventEmitter,b as Host,v as Parser,x as ParticleCook,Be as Paths,d as Runtime,E as Store,F as StoreCook,ce as fetchParticleCode,be as initVanilla,Ws as logFactory,le as maybeFetchParticleCode,G as pathForKind,k as requireParticleBaseCode,$t as requireParticleImplCode,Z as utils};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file or at
 * https://developers.google.com/open-source/licenses/bsd
 */
//# sourceMappingURL=arcs.min.js.map
